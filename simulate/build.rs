extern crate common;
extern crate csv;
extern crate nalgebra;

use common::ext::{ExtendPoint3, ExtendUnitQuaternion, ExtendVector3};
use nalgebra::{Point2, Point3, Real, UnitComplex, UnitQuaternion, Vector2, Vector3};
use std::{
    env,
    fmt::Write as FmtWrite,
    fs::File,
    io::{Read, Write},
    path::PathBuf,
};

/// Load data from the CSVs in `data`, and generate constants so the data is
/// available at runtime.
///
/// These CSVs were generated by the `collect` crate.
fn main() {
    let crate_dir = env::current_dir().unwrap();
    let csv_dir = crate_dir.join("data");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let mut out = File::create(out_dir.join("tables.rs")).unwrap();

    writeln!(&mut out, "use nalgebra::{{Point2, Vector2}};\n",).unwrap();

    for entry in csv_dir.read_dir().unwrap() {
        let path = entry.unwrap().path();
        if path.extension().unwrap().to_str() != Some("csv") {
            continue;
        }

        let file = File::open(&path).unwrap();

        let basename = path
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap()
            .replace(".", "_");
        let legacy = ["aerial_60deg", "boost", "coast", "jump", "throttle"]
            .iter()
            .any(|&s| s == basename);
        let r = csv::ReaderBuilder::new()
            .has_headers(!legacy)
            .from_reader(file);

        if legacy {
            compile_csv_legacy(&basename, r, &mut out);
        } else {
            compile_csv(&basename, r, &mut out);
        }
    }
}

fn compile_csv(name: &str, mut csv: csv::Reader<impl Read>, w: &mut impl Write) {
    let name = name.to_ascii_uppercase();

    let rows: Vec<_> = csv.records().map(Result::unwrap).collect();
    let headers = csv.headers().unwrap();

    macro_rules! col {
        ($column:expr) => {{
            let column = headers.iter().position(|h| h == $column).unwrap();
            rows.iter().map(move |ref row| &row[column])
        }};
    }

    macro_rules! write_array {
        ($suffix:expr, $type:expr, $items:expr) => {
            writeln!(w, "#[allow(dead_code)]").unwrap();
            writeln!(w, "pub const {}{}: &[f32] = &[", name, $suffix).unwrap();
            for x in $items {
                writeln!(w, "    {},", x).unwrap();
            }
            writeln!(w, "];\n").unwrap();
        };
    }

    macro_rules! write_lazy_static_array {
        ($suffix:expr, $type:expr, $items:expr) => {
            let items = $items;
            writeln!(w, "#[allow(dead_code)]").unwrap();
            writeln!(w, "lazy_static! {{").unwrap();
            writeln!(
                w,
                "    pub static ref {}{}: [{}; {}] = [",
                name,
                $suffix,
                $type,
                items.len(),
            )
            .unwrap();
            for x in items {
                writeln!(w, "        {},", x).unwrap();
            }
            writeln!(w, "    ];").unwrap();
            writeln!(w, "}}\n").unwrap();
        };
    }

    let time = if headers.iter().any(|h| h == "time") {
        col!("time")
            .map(|x| x.parse::<f32>().unwrap())
            .collect::<Vec<_>>()
    } else {
        col!("frame")
            .map(|x| x.parse::<f32>().unwrap() / 120.0)
            .collect::<Vec<_>>()
    };

    let player0_loc = col!("player0_loc_x")
        .zip(col!("player0_loc_y"))
        .zip(col!("player0_loc_z"))
        .map(|((x, y), z)| {
            Point3::<f32>::new(x.parse().unwrap(), y.parse().unwrap(), z.parse().unwrap())
        });

    let player0_rot = col!("player0_rot_x")
        .zip(col!("player0_rot_y"))
        .zip(col!("player0_rot_z"))
        .zip(col!("player0_rot_w"))
        .map(|(((x, y), z), w)| {
            UnitQuaternion::<f32>::xyzw(
                x.parse().unwrap(),
                y.parse().unwrap(),
                z.parse().unwrap(),
                w.parse().unwrap(),
            )
        });

    let player0_vel = col!("player0_vel_x")
        .zip(col!("player0_vel_y"))
        .zip(col!("player0_vel_z"))
        .map(|((x, y), z)| {
            Vector3::<f32>::new(x.parse().unwrap(), y.parse().unwrap(), z.parse().unwrap())
        });

    let player0_loc_2d = player0_loc.map(|x| x.to_2d());
    let player0_rot_2d = player0_rot.map(|x| x.to_2d()).collect::<Vec<_>>();
    let player0_vel_2d = player0_vel.map(|x| x.to_2d());

    write_array!("_TIME", "f32", time.iter().map(|x| x.to_source()));
    write_lazy_static_array!(
        "_CAR_LOC_2D",
        "Point2<f32>",
        player0_loc_2d.map(|x| x.to_source())
    );
    write_array!("_CAR_VEL_Y", "f32", col!("player0_vel_y").map(floatify));
    write_lazy_static_array!(
        "_CAR_VEL_2D",
        "Vector2<f32>",
        player0_vel_2d.map(|x| x.to_source())
    );
    write_array!(
        // CUM = cumulative, e.g. don't wrap from -180° to 180°.
        "_CAR_ROT_2D_ANGLE_CUM",
        "f32",
        player0_rot_2d.iter().scan(0.0, |state, rot| {
            *state += UnitComplex::new(*state).rotation_to(rot).angle();
            Some(state.to_source())
        })
    );
}

fn compile_csv_legacy(name: &str, mut csv: csv::Reader<impl Read>, w: &mut impl Write) {
    let mut out_time = format!(
        "#[allow(dead_code)]\npub const {}_TIME: &[f32] = &[\n",
        name.to_ascii_uppercase(),
    );
    let mut out_time_rev = "\n];\n\n".chars().rev().collect::<String>();
    let mut out_car_loc_y = format!(
        "#[allow(dead_code)]\npub const {}_CAR_LOC_Y: &[f32] = &[\n",
        name.to_ascii_uppercase(),
    );
    let mut out_car_loc_z = format!(
        "#[allow(dead_code)]\npub const {}_CAR_LOC_Z: &[f32] = &[\n",
        name.to_ascii_uppercase(),
    );
    let mut out_car_vel_y = format!(
        "#[allow(dead_code)]\npub const {}_CAR_VEL_Y: &[f32] = &[\n",
        name.to_ascii_uppercase(),
    );
    // Write some things backwards to avoid loading the entire CSV in memory.
    // I have 32GB of RAM and I'm aware this is pretty ridiculous.
    let mut out_car_vel_y_rev = "\n];\n\n".chars().rev().collect::<String>();

    for row in csv.records() {
        let row = row.unwrap();
        let time = floatify(&row[0]);
        let _ball_loc_x = floatify(&row[1]);
        let _ball_loc_y = floatify(&row[2]);
        let _ball_loc_z = floatify(&row[3]);
        let _ball_rot_pitch = floatify(&row[4]);
        let _ball_rot_yaw = floatify(&row[5]);
        let _ball_rot_roll = floatify(&row[6]);
        let _ball_vel_x = floatify(&row[7]);
        let _ball_vel_y = floatify(&row[8]);
        let _ball_vel_z = floatify(&row[9]);
        let _ball_ang_vel_x = floatify(&row[10]);
        let _ball_ang_vel_y = floatify(&row[11]);
        let _ball_ang_vel_z = floatify(&row[12]);
        let _car_loc_x = floatify(&row[13]);
        let car_loc_y = floatify(&row[14]);
        let car_loc_z = floatify(&row[15]);
        let _car_rot_pitch = floatify(&row[16]);
        let _car_rot_yaw = floatify(&row[17]);
        let _car_rot_roll = floatify(&row[18]);
        let _car_vel_x = floatify(&row[19]);
        let car_vel_y = floatify(&row[20]);
        let _car_vel_z = floatify(&row[21]);
        let _car_ang_vel_x = floatify(&row[22]);
        let _car_ang_vel_y = floatify(&row[23]);
        let _car_ang_vel_z = floatify(&row[24]);

        write!(&mut out_time, "    {},\n", time).unwrap();
        write!(
            &mut out_time_rev,
            "\n,{}    ",
            time.chars().rev().collect::<String>()
        )
        .unwrap();
        write!(&mut out_car_loc_y, "    {},\n", car_loc_y).unwrap();
        write!(&mut out_car_loc_z, "    {},\n", car_loc_z).unwrap();
        write!(&mut out_car_vel_y, "    {},\n", car_vel_y).unwrap();
        write!(
            &mut out_car_vel_y_rev,
            "\n,{}    ",
            car_vel_y.chars().rev().collect::<String>()
        )
        .unwrap();
    }

    write!(&mut out_time, "\n];\n\n").unwrap();
    out_time_rev
        .write_str(
            &format!(
                "#[allow(dead_code)]\npub const {}_TIME_REV: &[f32] = &[\n",
                name.to_ascii_uppercase()
            )
            .chars()
            .rev()
            .collect::<String>(),
        )
        .unwrap();
    write!(&mut out_car_loc_y, "\n];\n\n").unwrap();
    write!(&mut out_car_loc_z, "\n];\n\n").unwrap();
    write!(&mut out_car_vel_y, "\n];\n\n").unwrap();
    out_car_vel_y_rev
        .write_str(
            &format!(
                "#[allow(dead_code)]\npub const {}_CAR_VEL_Y_REV: &[f32] = &[\n",
                name.to_ascii_uppercase()
            )
            .chars()
            .rev()
            .collect::<String>(),
        )
        .unwrap();

    write!(w, "{}", out_time).unwrap();
    write!(w, "{}", out_time_rev.chars().rev().collect::<String>()).unwrap();
    write!(w, "{}", out_car_loc_y).unwrap();
    write!(w, "{}", out_car_loc_z).unwrap();
    write!(w, "{}", out_car_vel_y).unwrap();
    write!(w, "{}", out_car_vel_y_rev.chars().rev().collect::<String>()).unwrap();
}

trait ToSource {
    fn to_source(&self) -> String;
}

impl ToSource for f32 {
    fn to_source(&self) -> String {
        floatify(self.to_string())
    }
}

impl<N: Real + ToSource> ToSource for Vector2<N> {
    fn to_source(&self) -> String {
        format!(
            "Vector2::new({x}, {y})",
            x = self.x.to_source(),
            y = self.y.to_source(),
        )
    }
}

impl<N: Real + ToSource> ToSource for Vector3<N> {
    fn to_source(&self) -> String {
        format!(
            "Vector3::new({x}, {y}, {z})",
            x = self.x.to_source(),
            y = self.y.to_source(),
            z = self.z.to_source(),
        )
    }
}

impl<N: Real + ToSource> ToSource for Point2<N> {
    fn to_source(&self) -> String {
        format!(
            "Point2::new({x}, {y})",
            x = self.x.to_source(),
            y = self.y.to_source(),
        )
    }
}

impl<N: Real + ToSource> ToSource for Point3<N> {
    fn to_source(&self) -> String {
        format!(
            "Point3::new({x}, {y}, {z})",
            x = self.x.to_source(),
            y = self.y.to_source(),
            z = self.z.to_source(),
        )
    }
}

impl<N: Real + ToSource> ToSource for UnitQuaternion<N> {
    fn to_source(&self) -> String {
        format!(
            "UnitQuaternion::from_quaternion(Quaternion::new({w}, {x}, {y}, {z}))",
            w = self.as_ref().coords.w.to_source(),
            x = self.as_ref().coords.x.to_source(),
            y = self.as_ref().coords.y.to_source(),
            z = self.as_ref().coords.z.to_source(),
        )
    }
}

fn floatify(s: impl Into<String>) -> String {
    let s = s.into();
    if s.contains(".") {
        s
    } else {
        format!("{}.0", s)
    }
}
