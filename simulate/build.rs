extern crate csv;

use std::borrow::Cow;
use std::env;
use std::fmt::Write as FmtWrite;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;

/// Load data from the CSVs in `data`, and generate constants so the data is
/// available at runtime.
///
/// The CSVs were generated by the `collect` crate.
fn main() {
    let crate_dir = env::current_dir().unwrap();
    let csv_dir = crate_dir.join("data");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let mut out = File::create(out_dir.join("tables.rs")).unwrap();

    for entry in csv_dir.read_dir().unwrap() {
        let entry = entry.unwrap();
        let filename = entry.file_name().into_string().unwrap();
        if !filename.ends_with(".csv") {
            continue;
        }

        let basename = filename.split_terminator(".").next().unwrap();
        let csv = File::open(entry.path()).unwrap();
        let r = csv::Reader::from_reader(csv);
        compile_csv(basename, r, &mut out);
    }
}

fn compile_csv<R, W>(name: &str, mut csv: csv::Reader<R>, w: &mut W)
where
    R: Read,
    W: Write,
{
    let mut out_time = format!(
        "pub const {}_TIME: &'static [f32] = &[\n",
        name.to_ascii_uppercase()
    );
    let mut out_vel_y = format!(
        "pub const {}_VEL_Y: &'static [f32] = &[\n",
        name.to_ascii_uppercase()
    );

    for row in csv.records() {
        let row = row.unwrap();
        let time = floatify(&row[0]);
        let _loc_x = floatify(&row[1]);
        let _loc_y = floatify(&row[2]);
        let _loc_z = floatify(&row[3]);
        let _rot_pitch = floatify(&row[4]);
        let _rot_yaw = floatify(&row[5]);
        let _rot_roll = floatify(&row[6]);
        let _vel_x = floatify(&row[7]);
        let vel_y = floatify(&row[8]);
        let _vel_z = floatify(&row[9]);
        let _ang_vel_x = floatify(&row[10]);
        let _ang_vel_y = floatify(&row[11]);
        let _ang_vel_z = floatify(&row[12]);

        write!(&mut out_time, "{},", time);
        write!(&mut out_vel_y, "{},", vel_y);
    }

    write!(&mut out_time, "];\n");
    write!(&mut out_vel_y, "];\n");

    write!(w, "{}", out_time);
    write!(w, "{}", out_vel_y);
}

fn floatify(s: &str) -> Cow<str> {
    if s.contains(".") {
        Cow::Borrowed(s)
    } else {
        Cow::Owned(s.to_owned() + ".0")
    }
}
