#![warn(future_incompatible, rust_2018_compatibility, rust_2018_idioms, unused)]
#![cfg_attr(feature = "strict", deny(warnings))]
#![warn(clippy::all)]

use common::prelude::*;
use nalgebra::{UnitComplex, UnitQuaternion};
use std::{
    env,
    fs::File,
    io::{Read, Write},
    path::PathBuf,
};

/// Load data from the CSVs in `data`, and generate constants so the data is
/// available at runtime.
///
/// These CSVs were generated by the `collect` crate.
fn main() {
    let crate_dir = env::current_dir().unwrap();
    let csv_dir = crate_dir.join("data");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let mut out = File::create(out_dir.join("data.rs")).unwrap();

    for entry in csv_dir.read_dir().unwrap() {
        let path = entry.unwrap().path();
        if path.extension().unwrap().to_str() != Some("csv") {
            continue;
        }

        let basename = path
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap()
            .replace(".", "_");
        let legacy = basename == "throttle_frames";

        let file = File::open(&path).unwrap();
        let r = csv::ReaderBuilder::new().from_reader(file);

        compile_csv(&basename, r, &mut out, legacy);
    }
}

fn compile_csv(name: &str, mut csv: csv::Reader<impl Read>, w: &mut impl Write, legacy: bool) {
    let rows: Vec<_> = csv.records().map(Result::unwrap).collect();
    let headers = csv.headers().unwrap();

    macro_rules! col {
        ($column:expr) => {{
            let column = headers.iter().position(|h| h == $column).unwrap();
            rows.iter().map(move |ref row| &row[column])
        }};
    }

    macro_rules! write_array {
        ($name:expr, $type:expr, $items:expr $(,)*) => {
            let items = $items;
            writeln!(w, "    pub const {}: &[{}] = &[", $name, $type).unwrap();
            for x in items {
                writeln!(w, "        {},", x).unwrap();
            }
            writeln!(w, "    ];\n").unwrap();
        };
    }

    let time = if !legacy {
        col!("time")
            .map(|x| x.parse::<f32>().unwrap())
            .collect::<Vec<_>>()
    } else {
        col!("frame")
            .map(|x| x.parse::<f32>().unwrap() / 120.0)
            .collect::<Vec<_>>()
    };

    let player0_rot = col!("player0_rot_x")
        .zip(col!("player0_rot_y"))
        .zip(col!("player0_rot_z"))
        .zip(col!("player0_rot_w"))
        .map(|(((x, y), z), w)| {
            UnitQuaternion::<f32>::xyzw(
                x.parse().unwrap(),
                y.parse().unwrap(),
                z.parse().unwrap(),
                w.parse().unwrap(),
            )
        })
        .collect::<Vec<_>>();

    let player0_rot_2d = player0_rot.iter().map(|r| r.to_2d()).collect::<Vec<_>>();
    let player0_rot_2d_angle_cum = player0_rot_2d
        .iter()
        .scan(0.0, |state, rot| {
            *state += UnitComplex::new(*state).angle_to(rot);
            Some(state.to_source())
        })
        .collect::<Vec<_>>();

    writeln!(w, "pub mod {} {{", name).unwrap();
    writeln!(w, "    use lazy_static::lazy_static;\n").unwrap();
    writeln!(w, "    use nalgebra::{{Point2, Vector2}};\n").unwrap();
    write_array!("TIME", "f32", time.iter().map(|x| x.to_source()));
    write_array!("TIME_REV", "f32", time.iter().rev().map(|x| x.to_source()));
    write_array!("CAR_LOC_X", "f32", col!("player0_loc_x").map(floatify));
    write_array!("CAR_LOC_Y", "f32", col!("player0_loc_y").map(floatify));
    write_array!("CAR_LOC_Z", "f32", col!("player0_loc_z").map(floatify));
    write_array!(
        "CAR_LOC_Y_REV",
        "f32",
        col!("player0_loc_y").rev().map(floatify),
    );
    write_array!("CAR_VEL_X", "f32", col!("player0_vel_x").map(floatify));
    write_array!("CAR_VEL_Y", "f32", col!("player0_vel_y").map(floatify));
    write_array!(
        "CAR_VEL_Y_REV",
        "f32",
        col!("player0_vel_y").rev().map(floatify),
    );
    write_array!("CAR_ROT_2D_ANGLE_CUM", "f32", player0_rot_2d_angle_cum);
    writeln!(w, "    lazy_static! {{
        pub static ref CAR_LOC_2D: Vec<Point2<f32>> = CAR_LOC_X.iter().zip(CAR_LOC_Y.iter()).map(|(&x, &y)| Point2::new(x, y)).collect();
        pub static ref CAR_VEL_2D: Vec<Vector2<f32>> = CAR_VEL_X.iter().zip(CAR_VEL_Y.iter()).map(|(&x, &y)| Vector2::new(x, y)).collect();\
    }}")
    .unwrap();
    writeln!(w, "}}\n").unwrap();
}

trait ToSource {
    fn to_source(&self) -> String;
}

impl ToSource for f32 {
    fn to_source(&self) -> String {
        floatify(self.to_string())
    }
}

fn floatify(s: impl Into<String>) -> String {
    let s = s.into();
    if s.contains(".") {
        s
    } else {
        format!("{}.0", s)
    }
}
